<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Geospatial Visualization – Massachusetts</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<style>
  body {
    font-family: 'Segoe UI', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #fafafa;
    margin: 0;
    padding: 20px;
  }
  h1 { text-align: center; margin-bottom: 0; }
  h3 { text-align: center; margin-top: 5px; color: #555; }

  .map-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px 0;
  }
  svg {
    width: 700px;
    height: 450px;
    border: 1px solid #ccc;
    margin: 10px 0;
  }
  .tooltip {
    position: absolute;
    background: white;
    border: 1px solid #ccc;
    padding: 8px;
    font-size: 13px;
    border-radius: 6px;
    pointer-events: none;
    display: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  }
</style>
</head>
<body>

<h1>Geospatial Visualizations – Massachusetts</h1>
<h3>Your Name</h3>

<div class="map-container">
  <h2>Map A – Simulated Population in 1980</h2>
  <svg id="mapA"></svg>

  <h2>Map B – Simulated Population Change (1980–2010)</h2>
  <svg id="mapB"></svg>

  <h2>Map C – Gini Index by County (2019)</h2>
  <svg id="mapC"></svg>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
const width = 700, height = 450;
const tooltip = d3.select("#tooltip");

Promise.all([
  d3.json("data/towns.topojson"),
  d3.csv("data/gini_index.csv")
]).then(([topology, giniData]) => {

  const geojson = topojson.feature(topology, Object.values(topology.objects)[0]);

  // Simulated population data
  const popData = giniData.map(d => ({
    name: d["Geographic Area Name"],
    pop1980: Math.random() * 50000 + 10000,
    pop2010: Math.random() * 80000 + 20000
  }));
  const popMap = new Map(popData.map(d => [d.name, d]));
  const giniMap = new Map(giniData.map(d => [d["Geographic Area Name"], +d["Estimate!!Gini Index"]]));
  const giniByTown = d3.group(giniData, d => d["Geographic Area Name"]);

  const projection = d3.geoMercator().fitSize([width, height], geojson);
  const path = d3.geoPath().projection(projection);

  // Legend function
  function createLegend(svg, colorScale, width = 200, height = 12) {
    const defs = svg.append("defs");
    const gradientId = `grad-${Math.random().toString(36).substr(2, 5)}`;
    const gradient = defs.append("linearGradient")
                         .attr("id", gradientId)
                         .attr("x1", "0%").attr("x2", "100%")
                         .attr("y1", "0%").attr("y2", "0%");
    const n = 10;
    const domain = colorScale.domain();
    for (let i = 0; i <= n; i++) {
      gradient.append("stop")
        .attr("offset", `${i/n*100}%`)
        .attr("stop-color", colorScale(domain[0] + i/n*(domain[1]-domain[0])));
    }

    svg.append("rect")
      .attr("x", 10)
      .attr("y", +svg.attr("height") - 30)
      .attr("width", width)
      .attr("height", height)
      .style("fill", `url(#${gradientId})`);

    svg.append("text")
      .attr("x", 10)
      .attr("y", +svg.attr("height") - 35)
      .text(Math.round(domain[0]))
      .style("font-size", "10px");

    svg.append("text")
      .attr("x", 10 + width)
      .attr("y", +svg.attr("height") - 35)
      .text(Math.round(domain[1]))
      .style("font-size", "10px")
      .attr("text-anchor", "end");
  }

  // ---------- MAP A ----------
  const svgA = d3.select("#mapA");
  const colorA = d3.scaleSequential(d3.interpolateBlues)
                   .domain(d3.extent(popData, d => d.pop1980));

  svgA.selectAll("path")
    .data(geojson.features)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const p = popMap.get(d.properties.TOWN || d.properties.TOWN_NAME || d.properties.NAME);
      return p ? colorA(p.pop1980) : "#ccc";
    })
    .attr("stroke", "#333")
    .on("mouseenter", (event, d) => {
      d3.select(event.currentTarget).attr("stroke-width", 2).attr("stroke", "black");
      const p = popMap.get(d.properties.TOWN || d.properties.TOWN_NAME || d.properties.NAME);
      tooltip.style("display", "block")
             .html(`<strong>${d.properties.TOWN || d.properties.TOWN_NAME}</strong><br>
                    Population (1980): ${p ? Math.round(p.pop1980) : "N/A"}`);
    })
    .on("mousemove", event => tooltip.style("left", (event.pageX + 10) + "px")
                                     .style("top", (event.pageY - 28) + "px"))
    .on("mouseleave", event => {
      tooltip.style("display", "none");
      d3.select(event.currentTarget).attr("stroke-width", 1).attr("stroke", "#333");
    });

  createLegend(svgA, colorA);

  // ---------- MAP B ----------
  const svgB = d3.select("#mapB");
  const colorB = d3.scaleDiverging(d3.interpolateRdYlGn)
                   .domain([-50000, 0, 50000]);

  svgB.selectAll("path")
    .data(geojson.features)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const p = popMap.get(d.properties.TOWN || d.properties.TOWN_NAME || d.properties.NAME);
      return p ? colorB(p.pop2010 - p.pop1980) : "#ccc";
    })
    .attr("stroke", "#333")
    .on("mouseenter", (event, d) => {
      d3.select(event.currentTarget).attr("stroke-width", 2).attr("stroke", "black");
      const p = popMap.get(d.properties.TOWN || d.properties.TOWN_NAME || d.properties.NAME);
      tooltip.style("display", "block")
             .html(`<strong>${d.properties.TOWN || d.properties.TOWN_NAME}</strong><br>
                    Change (1980–2010): ${p ? Math.round(p.pop2010 - p.pop1980) : "N/A"}`);
    })
    .on("mousemove", event => tooltip.style("left", (event.pageX + 10) + "px")
                                     .style("top", (event.pageY - 28) + "px"))
    .on("mouseleave", event => {
      tooltip.style("display", "none");
      d3.select(event.currentTarget).attr("stroke-width", 1).attr("stroke", "#333");
    });

  createLegend(svgB, colorB);

  // ---------- MAP C ----------
  const svgC = d3.select("#mapC");
  const colorC = d3.scaleSequential(d3.interpolateOrRd)
                   .domain(d3.extent(giniData, d => +d["Estimate!!Gini Index"]));

  svgC.selectAll("path")
    .data(geojson.features)
    .join("path")
    .attr("d", path)
    .attr("fill", d => {
      const g = giniMap.get(d.properties.TOWN || d.properties.TOWN_NAME || d.properties.NAME);
      return g ? colorC(g) : "#ccc";
    })
    .attr("stroke", "#333")
    .on("mouseenter", (event, d) => {
      const townName = d.properties.TOWN || d.properties.TOWN_NAME || d.properties.NAME;
      const data = giniByTown.get(townName) || [];

      tooltip.style("display", "block")
             .style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 150) + "px")
             .html(`<strong>${townName}</strong><br>Gini Index over Years<br>`);

      // Add mini line chart
      const margin = {top:10,right:10,bottom:20,left:30}, w=150,h=80;
      const x = d3.scaleLinear().domain(d3.extent(data, d=>+d.year)).range([0,w]);
      const y = d3.scaleLinear().domain([0, d3.max(data, d=>+d["Estimate!!Gini Index"])]).range([h,0]);
      const lineGen = d3.line()
                        .x(d=>x(+d.year))
                        .y(d=>y(+d["Estimate!!Gini Index"]));
      const svgTooltip = tooltip.append("svg")
                          .attr("width", w + margin.left + margin.right)
                          .attr("height", h + margin.top + margin.bottom)
                          .append("g")
                          .attr("transform", `translate(${margin.left},${margin.top})`);
      svgTooltip.append("path")
                .datum(data)
                .attr("d", lineGen)
                .attr("stroke","steelblue")
                .attr("fill","none")
                .attr("stroke-width",1.5);
    })
    .on("mousemove", event => tooltip.style("left", (event.pageX + 10) + "px")
                                     .style("top", (event.pageY - 150) + "px"))
    .on("mouseleave", event => {
      tooltip.style("display","none").html("");
      d3.select(event.currentTarget).attr("stroke-width", 1).attr("stroke", "#333");
    });

  createLegend(svgC, colorC);

});
</script>
</body>
</html>
